= CoreOS From The Ground Up
In
https://electron-swamp.blogspot.com/2025/01/the-case-for-coreos-network.html[the
first post] in this series I laid out a set of arguments to support
the use of https://fedoraproject.org/coreos[Fedora CoreOS] to host
network services for small and medium local networks. That was the
*why*. In this one I mean to show the first step of the *how*.

==  Installation

OS installation is, at it's most basic, writing data to a storage unit
for first boot. The storage can be a spinning disk, or an SSD of
one form or another (I'm going to use 'disk' from here on in for
any bootable storage media). Most distributions provide a bootable
image with an interactive installer program on it, and in many
cases a GUI interface. These guide a normal user through a
one-time process and the result is a complete running desktop for
the user. Server distributions often provide a way (for instance,
Red Hat Kickstart) to define and apply all the changes an admin
would want for system initialization. These include complex disk
and network configurations, package selection, user definitions.

The other extreme is an OS
that is provided as a binary image and is merely copied to the
destination. This is the most common method for distributions
made for small ARM machines like Raspberry Pi. To customize one
of these you have to write to the media and then mount the
image on a running machine (like my laptop) and make the needed
changes before the first boot. I often do this to enable the
UART for a serial console and to place an SSH private key for
the default user.

== The CoreOS Installer

CoreOS falls somewhere in the middle. A new CoreOS instance is written to the disk using
a single CLI command: `https://github.com/coreos/coreos-installer[coreos-installer]`.

The installer can be run from a bootable live-image of CoreOS or it
can run on a separate machine with the storage temporarily
attached. The installer is available on Fedora Linux in the RPM of the
same name. 
	
In it's simplest form the installer takes only a single argument: the
location to write the image data.

[source, bash]
----
sudo coreos-installer install /dev/sdb
----

This command will pull the default stream (stable) from the default
location (the Fedora CoreOS download repository) and write it onto the
indicated block device. In this example it is an SD card that was
previously inserted into a USB port. The installer does not make any
customisations to the image.

**NOTE:** *Be sure to unmount any auto-mounted existing filesystems from the device before overwriting.*

**WARNING:** *Be sure you're writing to the correct device. Overwriting your OS is easy and painful.*

The install command can take a number of arguments to select the image
stream, the image source and to control the target platform and
architecture. We'll use these only as needed to vary from the
defaults. We will use two arguments that indicate where to find a
configuration file that will be laid into the image and used on first
boot to complete the customization. We'll use slightly different
arguments for the two sample targets based on the installation method
and the characteristics of the target devices. Before we can run the
installer we need to define the customisations and generate the
configuration files for the target systems.

== Something About Fire Metaphors

The minimalist nature of CoreOS means there aren't a lot of knobs that
need setting to get a basic running system. The CLI arguments for
coreos-installer define what image gets placed and where, but they
don't make any changes to the image itself. To customize the installed
system we need to define the elements we want configured and what
values we want them to have.

CoreOS actually uses two semantically identical configuration
specifications. Users provide their configuration using the
https://coreos.github.io/butane/[butane] then transform it into
https://coreos.github.io/ignition/[ignition] format to submit to the
installer for first boot

Ignition is a JSON structured data format that was defined for the
original CoreOS. At some point, someone decided that JSON was too
difficult for sysadmins to manage, so Butane was defined using YAML
for structured data instead. I'm not sure why no one just included a
YAML parser on the CoreOS image, but for now the workflow for creating
configurations is to write the configuration in Butane (YAML) and then
transform it into Ignition (JSON) and then to submit that to the
installer.

While annoying, this process does have one significant benefit. The
butane command runs validation on the configuration file during the
transformation and reports any schema violations so that they can be
corrected before installation. This doesn't do anything to make sure
that the configuration values are correct, but at least it insures
that there are no errors in the white-space delimited YAML form.

== Make It Your Own

The Butane specification only has two required fields to start the YAML file:

    variant: fcos
    version: 1.6.0

This indicates thats the target system is Fedora CoreOS and that the
Butane schema version is 1.6.0. The following fields must all
conform to that schema, but all of the fields are
optional.

Who Are You? Who Who? Who Who?

A bare CoreOS image will boot and initialize any NICs it
detects. Without any configuration provided each NIC that
detects link will broadcast a DHCP request. The system will
configure the NICs according to the DHCP response that they
receive. If the NIC's MAC address has a lease reservation
defined, the DHCP server will provide a stable known IP
address in the DHCP response. Finally the system will start
an SSH daemon attached to the active interfaces and begin
accepting inbound connection requests.

The basic image only has two users defined: root and core

Neither user has a password defined or a public key set to allow a user
to log in. By convention the root user never does.
The core user is a member of the sudoers group and so can
escalate privileges as needed... once the user is logged in.

The Butane spec includes a section for defining new users
including providing an SSH public key. It is possible also
to provide a password, but that places sensitive
information (the password hash) into the butane file and so
is discouraged. New users, and user customisations are
defined in the passwords section.

    passwords:
      users:
        - name: core:
	  ssh_authorized_keys: |
            ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGl7GOHs9enyGZ7tTSh8E8G5mE+B9gyVVnz41hRyxbbN Infrastructure Ansible Key

The core user already exists so the user will be created as
default. This section just tells the Ignition system to add this
public key to the core user's authorized_keys file. After first boot,
a user holding the private key will be able to log into the new system
as the coreuser.

== Where Am I?

The only other configuration I like to make is to tell the system it's
own name. The system name is defined in /etc/hostname so I'll add a
section to create this file and insert the text needed.

== Installer Controls

There are a number of CLI arguments for the installer that are used to affect the
image results. These are used to select custom image stream
or locations. In this demonstration we're only going to use two, both related to
 
