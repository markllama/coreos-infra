= CoreOS From The Ground Up

In https://electron-swamp.blogspot.com/2025/01/the-case-for-coreos-network.html[the
first post] in this series I laid out a set of arguments to support
the use of https://fedoraproject.org/coreos[Fedora CoreOS] to host
network services for small and medium local networks. That was the
*why*. In this one I mean to show the first step of the *how*.

==  Installation

OS installation is, at it's most basic, writing data to a storage unit
for first boot. The storage can be a spinning disk, or an SSD of
one form or another (I'm going to use 'disk' from here on in for
any bootable storage media). Most distributions provide a bootable
image with an interactive installer program on it, and in many
cases a GUI interface. These guide a normal user through a
one-time process and the result is a complete running desktop for
the user. Server distributions often provide a way (for instance,
Red Hat Kickstart) to define and apply all the changes an admin
would want for system initialization. These include complex disk
and network configurations, package selection, user definitions.

The other extreme is an OS that is provided as a binary image and is
merely copied to the destination. This is the most common method for
distributions made for small ARM machines like Raspberry Pi. To
customize one of these you have to write to the media and then mount
the image on a running machine (like my laptop) and make the needed
changes before the first boot. I often do this to enable the UART for
a serial console and to place an SSH private key for the default user.

=== Configuration

The minimalist nature of CoreOS means there aren't a lot of knobs that
need setting to get a basic running system. The CLI arguments for
coreos-installer define what image gets placed and where, but they
don't make any changes to the image itself. To customize the installed
system we need to define the elements we want configured and what
values we want them to have.

==== Config Formats

CoreOS actually uses two semantically identical configuration
specifications. Users provide their configuration using the
https://coreos.github.io/butane/[butane] then transform it into
https://coreos.github.io/ignition/[ignition] format to submit to the
installer for first boot

Ignition is a JSON structured data format that was defined for the
original CoreOS. At some point, someone decided that JSON was too
difficult for sysadmins to manage, so Butane was defined using YAML
for structured data instead. I'm not sure why no one just included a
YAML parser on the CoreOS image, but for now the workflow for creating
configurations is to write the configuration in Butane (YAML) and then
transform it into Ignition (JSON) and then to submit that to the
installer.

While annoying, this process does have one significant benefit. The
butane command runs validation on the configuration file during the
transformation and reports any schema violations so that they can be
corrected before installation. This doesn't do anything to make sure
that the configuration values are correct, but at least it insures
that there are no errors in the white-space delimited YAML form.

==== Make It Your Own

CoreOS is by design a minimal distribution and the initial
configuration is comparably sparse. You can create lots of users and
place arbitrary files and apply complex controls to the storage
configuration and placement, but on a simple system there's really no need.

The only customizations needed to start are those that identify the
system and provide the initial access for further configuration. The
file below is near the the simplest system configuration you can have.

[source, yaml]
.`coreos-config.bu`
----
---
# Indicate the spec and version for the parser
variant: fcos
version: 1.6.0

# set the hostname of the system
storage:
  files:
    - path: /etc/hostname
      contents:
        inline: |
          coreos-01.example.com

# set a pub key for the core user
passwd:
  users:
    - name: core
      # depends on butane --files-dir argument
      ssh_authorized_keys_local:
        - core-ed25519.pub
----

This configuration is applied during first-boot from the `ignition`
service on the `initrd`, a ram disk stage 1 boot system.

This configuration does not include either the storage layout or network
specs for the system. Complex storage configuration is part of the
spec, but for small system's it's not often useful. The network
configuration can be managed by DHCP or provided at the CLI
installation command.

=== Light It Up: Butane to Ignition

As noted in <<config-formats>> the system configuration is defined
using the Butane spec, but must be provided to the installer and
booting system in the Ignition format. The `butane` command validates
the configuration and transforms it for the installer.

The https://coreos.github.io/butane/getting-started[`butane` binary]
is available as an RPM on Fedora based distributions, but it is also
available as a software container. The butane transformer is a pure
pipeline. That is, it takes a stream of input on `stdin`, and some
arguments for how to transform the stream and writes the transformed
data to `stdout`. For simplicity the examples here assume that
`butane` is either installed or that the container invokation has been
defined as a shell alias.




== The CoreOS Installer

CoreOS falls somewhere in the middle between interactive and simple
image copy installers.  A new CoreOS instance is written to the disk
using a single CLI command:
`https://github.com/coreos/coreos-installer[coreos-installer]`. The
installer can be run from a bootable live-image of CoreOS or it can
run on a separate machine with the storage temporarily attached. The
installer is available on Fedora Linux in the RPM of the same name.
	
In it's simplest form the installer takes only a single argument: the
location to write the image data.

[source, bash]
----
sudo coreos-installer install /dev/sdb
----

This command will pull the default stream (stable) from the default
location (the Fedora CoreOS download repository) and write it onto the
indicated block device. In this example it is an SD card that was
previously inserted into a USB port. The installer does not make any
customisations to the image.

**NOTE:** *Be sure to unmount any auto-mounted existing filesystems from the device before overwriting.*

**WARNING:** *Be sure you're writing to the correct device. Overwriting your OS is easy and painful.*

The install command can take a number of arguments to select the image
stream, the image source and to control the target platform and
architecture. We'll use these only as needed to vary from the
defaults. We will use two arguments that indicate where to find a
configuration file that will be laid into the image and used on first
boot to complete the customization. We'll use slightly different
arguments for the two sample targets based on the installation method
and the characteristics of the target devices.

== Installer Controls

There are a number of CLI arguments for the installer that are used to affect the
image results. These are used to select custom image stream
or locations. In this demonstration we're only going to use two, both
related to the location of the Ignition configuration file.


 
