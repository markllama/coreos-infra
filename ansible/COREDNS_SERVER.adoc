:toc:
:toc-placement!:

// CoreDNS server by Ansible Playbook
= DNS Service - CoreDNS

https://coredns.io[CoreDNS] was developed for use in
https://kubernetes.io/[Kubernetes] as a light-weight name server for
containerized services. For a small to medium sized network, CoreDNS
is much simpler to configure and operate than any of the production
quality alternatives.

toc::[]

== Running CoreDNS

The CoreDNS configuration consists of a single configuration file and
a set of  https://en.wikipedia.org/wiki/Zone_file[DNS zone
files]. The files can be contained in a single directory, commonly
`/opt/coredns`. The program looks for a file called `Corefile` in the
current working directory when it is invoked. 

CoreDNS is meant to be run in a software container. CoreOS provides
https://podman.io[`podman`], a drop-in CLI replacement for Docker and
the `runc` runtime.

DNS servers listen to UDP port 53 for queries. TCP port 53 is used for
some operations such as zone transfers and secure DNS. By default it
listens on all configured interfaces.

The configuration used in this example is meant for use inside a
firewalled network. It does not serve queries to devices outside the
local network. It is meant to provide a split-dns

The CoreDNS container image is always found here:

    docker.io/coredns/coredns:latest

[coredns-server-playbook]
== `coredns-server` Playbook

The goal of the `coredns-server` playbook is to install and configure
CoreDNS on a set of servers. The servers need to listen for and
respond to DNS queries on port 53/UDP on one of a set of listed IPv4
addresses. The service runs in a software container and is managed as
a `systemd` service.

The deployment steps can be grouped into four related sets of tasks:

1. Switch to static resolver
1. Configure network interface
1. Deploy CoreDNS configuration
1. Configure `systemd` service

For clarities sake these four are broken down into separate task files
in the `coredns-server` role. These are detailed in corresponding
sections link:#coredns-server-role[below].

An Ansible playbook is defined in a `.yaml` formatted file. It is
possible to contain the entire playbook in a single file, but it is
usually helpful to have the playbook use a *role*. Roles are re-usable
modules that 

.link:coredns-server-pb.yaml[`coredns-server-pb.yaml`]
[source,yaml]
----
include::coredns-server-pb.yaml[]
---
#
# The playbook creates a DNS server on the target hosts using CoreDNS
# It populates the zone files from files/zones
#
- name: CoreDNS Server
  hosts: dnsservers
  become: true

  vars_files:
    - dns_services.yaml

  roles:
    - coredns-server
----

The `dns_services.yaml` file specifies the parameters for the CoreDNS
server. Among these are the locations and zones for the
https://en.wikipedia.org/wiki/Zone_file[zone files]. These reside in
`files/zones` in the ansible directory. The zone files here are static
and follow the RFC standards and will be familar to anyone who's
configured https://www.isc.org/bind/[ISC Bind]. They could be produced
mechanically from other databases but that is outside the scope of
this project.

.link:vars/dns_services.yaml[vars/dns_services.yaml]
[source.yaml]
----
---
#
# DNS services for example.com network
#
dns:
  nameservers:
    pi4-1:
      fqdn: ns1.example.org
      device: enabcm6e4ei0
      ipv4: 192.168.2.10
    pi4-2:
      fqdn: ns1.example.org
      device: enabcm6e4ei0
      ipv4: 192.168.2.11

  forwarders:
    - 192.168.2.1
    - 1.1.1.1
    - 1.0.0.1
    
  zones:
    - fqdn: example.org
      file: example.org.zone
    - fqdn: lab.example.org
      file: lab.example.org.zone

  search:
    - lan    # mDNS from Google Mesh DNS
    - example.org
    - lab.example.org
----


[#coredns-server-role]
== `coredns-server` Role

This role encapsulates the process of installing a CoreDNS server on a
host. The broad steps are described
link:#coredns-server-playbook[above]. 

.coredns-server role tree
----
roles/coredns-server/
├── files
│   └── coredns.container
├── handlers
│   └── main.yaml
├── tasks
│   ├── config_files.yaml
│   ├── main.yaml
│   ├── network.yaml
│   ├── resolver.yaml
│   └── systemd_service.yaml
└── templates
    ├── Corefile.j2
    └── resolv.conf.j2

5 directories, 9 files
----

The task files are the primary driver of a playbook and role. The rest
of the files provide resources that serve the tasks as they
are run.

=== `tasks/main.yaml`

The task files are the primary driver of a playbook and role. The rest
of the files provide resources that serve the tasks as they
are run. The file `main.yaml` acts as the entry point for the tasks
defined in the `tasks/` subdirectory. The tasks are defined as if they
were part of a playbook, as a YAML list. The `main.yaml` file refers
to a set of smaller task files, grouping the tasks functionally.

.`tasks/main.yaml`
[source,ansible]
----
---
#
# Coordinate creating a coredns service container
#
- name: Disable systemd-resolved and set static resolver file
  import_tasks: resolver.yaml

- name: Configure and set DNS Listener IP address
  import_tasks: network.yaml

- name: Place the Configration Files
  import_tasks: config_files.yaml

- name: Prepare Systemd Services
  import_tasks: systemd_service.yaml
----

Note that the first three sets of tasks are not special for
CoreOS. They're applicable to any DNS service. The final task list is
the important one for this series. 

=== Static DNS Resolver

Since 2020, with the release of Fedora 33, the the local DNS resolver
is a daemon integrated with `systemd`.  This daemon listens for local
queries and is bound to port 53/UDP. The CoreDNS server needs to bind
to the same port, so the `systemd-resolved` service must be stopped
and disabled before `coredns` can start.

This set of tasks disables the `systemd-resolved` service and replaces
the stock `/etc/resolv.conf` file with one configured for the target
environment.

.`tasks/resolver.yaml`
[source,yaml]
----
- name: Disable systemd-resolved - (avoid conflict with coredns)
  service:
    name: systemd-resolved
    state: stopped
    enabled: false

- name: Set static resolver file
  template:
    dest: /etc/resolv.conf
    src: resolv.conf.j2
    owner: root
    group: root
    mode: 0644
    backup: true
----

.`templates/resolve.conf.j2`
----
#
# Maintained by Ansible
#
nameserver 127.0.0.1
{% for nameserver in dns.forwarders %}
nameserver {{ nameserver }}
{% endfor %}
search {{ dns.search|join(' ') }}
----

The `resolv.conf` file directs DNS queries first to the local
nameserver and then to the listed forwarders when the local server
does not serve the requested domain.

=== DNS Listener IP Address

The DNS service requires two servers for each domain. The servers are
identified by IP address because, well they provide the name
services. This step ensures that each server host is listening on one
of those two addresses.

This task set finds the default interface on this host and then
creates a new connection that attaches to the physical one and answers
the servers listener address. The connection type is `macvlan` and it
allows this interface to be configured manually while allowing the
main interface to use DHCP for the rest of the network information.

The critical step here is the second one. It creates a virtual interface dedicated to
the DNS listener address.

.`tasks/network.yaml`
[source,yaml]
----
- name: Record interface name(s)
  set_fact:
    default_interface_name: "{{ ansible_default_ipv4.interface }}"
  tags: network

- name: Create macvlan interface for DNS server
  nmcli:
    type: macvlan
    conn_name: coredns
    ifname: coredns
    macvlan:
      mode: 2
      parent: "{{ default_interface_name }}"
    method4: manual
    ip4:
      - "{{ dns.nameservers[ansible_hostname].ipv4 }}/{{ ansible_default_ipv4.prefix }}"
    autoconnect: true
    state: present
  tags: network
  register: macvlan

- name: Restart NetworkManager if needed
  systemd:
    name: NetworkManager
    state: restarted
  when: macvlan.changed is true
  tags: network
----

This results in three visible changes in the network setup. A new *NetworkManager* connection, a new ip link and address.

[source,bash]
----
$ nmcli --fields connection.id,connection.type,macvlan.parent,macvlan.mode,ipv4.addresses c show coredns
connection.id:                          coredns
connection.type:                        macvlan
macvlan.parent:                         enabcm6e4ei0
macvlan.mode:                           2 (bridge)
ipv4.addresses:                         192.168.2.10/24

$ ip address show coredns
3: coredns@enabcm6e4ei0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether 06:71:b3:d4:46:8a brd ff:ff:ff:ff:ff:ff
    inet 192.168.2.10/24 brd 192.168.2.255 scope global noprefixroute coredns
       valid_lft forever preferred_lft forever
----

=== CoreDNS Configuration

The system is now able to run a DNS server answering on one of the listner IP addresses specified in the `vars/dns_servers.yaml` data file.


=== Add `systemd` Container Service


== References

* https://coredns.io[CoreDNS]
* https://www.isc.org/bind/[ISC Bind]
* https://kerbernetes.io[Kubernetes]
* https://en.wikipedia.org/wiki/Zone_file[DNS Zone Files]
